#!/usr/bin/env hy2

(import [time [sleep]]
        [lib.runner [Runner]]
        [lib.windows [Renderer Master Overview]]
        [lib.osc [nerve]]
        [lib.pyexec [pyexec]]
        [config [OSC_EAR OSC_EYE]])


(defclass Eye [Runner]
  "
  Handles and draws the different visions

  Recives from Coder:
    * `/eye/code    [filename code]`
    * `/eye/delete  [filename]` (not yet implemented)
    * `/eye/move    [oldname newname]`

  Sends to Ear:
    * `/ear/code  [cmd]` signal generated by lib.audio.source

  Recives from Ear:
    * `/eye/audio/[cmd]  [value]` signal handled by lib.audio.source

  Recives from Universe:
    * `[anything]  [?]` signal handled by lib.osc.source (not tested)
  "
  [ [__init__ (fn [self]
      (.__init__ Runner self)
      (setv self.visions {})
      (.sender nerve OSC_EAR)
      (.reciver nerve OSC_EYE))]

    [run (fn [self]
      (print "starting eye.hy")

      (.listen nerve "/eye/code" self.coder)
      (.listen nerve "/eye/move" self.moved)
      ;(.listen nerve "/eye/delete" self.deleted)

      (.start nerve)

      ; windows
      (setv renderer (Renderer self.visions))
      (setv master (Master))
      (setv overview (Overview))

      (.iteration self (fn []
        (.update renderer)
        (.update overview renderer.texture)
        (.update master renderer.texture)
        (sleep (/ 1 60))))

      (print "\rstopping eye.hy")
      (.stop nerve))]

    [coder (fn [self path args]
      (setv [name code] args)
      (if (in name (self.visions.keys))
        (.update (get self.visions name) code)
        (assoc self.visions name (Vision name code))))]

    [moved (fn [self path args]
      (setv [oldname newname] args)
      (if (in oldname (self.visions.keys))
        (do
          (.setName (get self.visions oldname) newname)
          (assoc self.visions newname (.pop self.visions oldname)))))]])


(defclass Vision []
  "
  The vision instance
  "
  [ [__init__ (fn [self name code]
      (.setName self name)

      ; stack here the loaded codes, so when everything explodes, we can
      ; always restore the last (opefully) working vision
      (setv self.stack [])

      (defclass Box []
        "A small sandbox where to run the livecoded part"
        [ [draw (fn [self])]])
      (setv self.box (Box))

      (.update self code)
      None)]

    [setName (fn [self name]
      (setv self.name (get (.split name "/") -1)))]

    [update (fn [self code]
      (print "\rloading:" self.name)
      (setv filename (% "visions/%s" self.name))
      (try
        (pyexec code self.box.__dict__)
        (except [e Exception]
          (print self.name e))
        (else
          (.append self.stack code))))]

    [iteration (fn [self]
      (try
        (.draw self)
        (except [e Exception]
          (print self.name self.name e)
          (.pop self.stack)

          ; if there is an error and stack is empty you are in the situation
          ; where the FIRST loaded vision is broken, that can be a problem
          ; (for you, if you are livecoding)
          (if self.stack
            (do
              (setv code (get self.stack -1))
              (pyexec code self.box.__dict__))
            (print self.name "BROKEN!")))))]

    [draw (fn [self]
      (.draw self.box))]])


(defmain [args]
  (.run (Eye)))
